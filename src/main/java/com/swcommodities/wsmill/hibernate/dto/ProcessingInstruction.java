package com.swcommodities.wsmill.hibernate.dto;
// Generated Feb 18, 2014 3:38:53 PM by Hibernate Tools 3.2.1.GA

import com.swcommodities.wsmill.domain.event.pi.NewlyCreatedPIEvent;
import com.swcommodities.wsmill.domain.event.pi.PIFinishedEvent;
import com.swcommodities.wsmill.domain.event.pi.PIUpdatedEvent;
import com.swcommodities.wsmill.domain.event.pi.PIUpdatedEventByRef;
import com.swcommodities.wsmill.domain.model.RefAware;
import com.swcommodities.wsmill.domain.model.exceptions.ActionNotPermitted;
import com.swcommodities.wsmill.domain.model.status.CompletionStatus;
import com.swcommodities.wsmill.domain.model.status.RequestStatus;

import static javax.persistence.GenerationType.IDENTITY;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.Table;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;

import com.swcommodities.wsmill.hibernate.dto.contract.OwnerInstruction;
import com.swcommodities.wsmill.utils.Constants;
import java.util.stream.Collectors;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import javax.persistence.Transient;
import org.springframework.data.domain.AbstractAggregateRoot;

/**
 * ProcessingInstruction generated by hbm2java
 */
@Entity
@Table(name = "processing_instruction")
public class ProcessingInstruction extends AbstractAggregateRoot implements java.io.Serializable, OwnerInstruction, RefAware {

    private Integer id;
    private User user;
    private ProcessingType processingType;
    private CompanyMaster companyMasterByClientId;
    private GradeMaster gradeMaster;
    private PackingMaster packingMaster;
    private int originId;
    private int qualityId;
    private String refNumber;
    private Date createdDate;
    private String clientRef;
    private float quantity;
    private Date fromDate;
    private Date toDate;
    private String remark;
    private byte status;
    private String log;
    private Set<WeightLoss> weightLosses = new HashSet<WeightLoss>(0);
    private Byte requestStatus;
    private Date requestStatusDate;
    private Date completionStatusDate;
    private String requestRemark;
    private Date creditDate;
    private User userByUpdateRequestUserId;
    private User userByUpdateCompletionUserId;
    private Date updatedDate;
    private PIType piType;

    private Double allocatedWeight; // in tons
    private Double inProcessWeight;
    private Double exProcessWeight;
    private Double pendingWeight;
    private Set<WeightNote> weightNotes;
    private Set<WnrAllocation> allocations;
    
    private CompletionStatus completionStatus = CompletionStatus.PENDING;
    private CompletionStatus completionStatus1 = CompletionStatus.PENDING;
    
    private RequestStatus requestStatusEnum = RequestStatus.PENDING;
    private RequestStatus requestStatusEnum1 = RequestStatus.PENDING;
    private User createdUser;

    private Boolean isCompletable;

    public ProcessingInstruction() {
    }

    public ProcessingInstruction(User user, ProcessingType processingType, CompanyMaster companyMasterByClientId, GradeMaster gradeMaster, PackingMaster packingMaster, int originId, int qualityId, String refNumber, Date createdDate, float quantity, byte status) {
        this.user = user;
        this.processingType = processingType;
        this.companyMasterByClientId = companyMasterByClientId;
        this.gradeMaster = gradeMaster;
        this.packingMaster = packingMaster;
        this.originId = originId;
        this.qualityId = qualityId;
        this.refNumber = refNumber;
        this.createdDate = createdDate;
        this.quantity = quantity;
        this.status = status;
    }

    public ProcessingInstruction(User user, ProcessingType processingType, CompanyMaster companyMasterByClientId, GradeMaster gradeMaster, PackingMaster packingMaster, int originId, int qualityId, String refNumber, Date createdDate, String clientRef, float quantity, Date fromDate, Date toDate, String remark, byte status, String log, Set<WeightLoss> weightLosses) {
        this.user = user;
        this.processingType = processingType;
        this.companyMasterByClientId = companyMasterByClientId;
        this.gradeMaster = gradeMaster;
        this.packingMaster = packingMaster;
        this.originId = originId;
        this.qualityId = qualityId;
        this.refNumber = refNumber;
        this.createdDate = createdDate;
        this.clientRef = clientRef;
        this.quantity = quantity;
        this.fromDate = fromDate;
        this.toDate = toDate;
        this.remark = remark;
        this.status = status;
        this.log = log;
        this.weightLosses = weightLosses;
    }

    @Id
    @GeneratedValue(strategy = IDENTITY)
    @Column(name = "id", unique = true, nullable = false)
    public Integer getId() {
        return this.id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    public User getUser() {
        return this.user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "created_user_id")
    public User getCreatedUser() {
		return createdUser;
	}

	public void setCreatedUser(User createdUser) {
		this.createdUser = createdUser;
	}

	@ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "type_id", nullable = true)
    public ProcessingType getProcessingType() {
        return this.processingType;
    }

    public void setProcessingType(ProcessingType processingType) {
        this.processingType = processingType;
    }

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "client_id", nullable = true)
    public CompanyMaster getCompanyMasterByClientId() {
        return this.companyMasterByClientId;
    }

    public void setCompanyMasterByClientId(CompanyMaster companyMaster) {
        this.companyMasterByClientId = companyMaster;
    }

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "grade_id", nullable = false)
    public GradeMaster getGradeMaster() {
        return this.gradeMaster;
    }

    public void setGradeMaster(GradeMaster gradeMaster) {
        this.gradeMaster = gradeMaster;
    }

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "packing_id", nullable = false)
    public PackingMaster getPackingMaster() {
        return this.packingMaster;
    }

    public void setPackingMaster(PackingMaster packingMaster) {
        this.packingMaster = packingMaster;
    }

    @Column(name = "origin_id", nullable = true)
    public int getOriginId() {
        return this.originId;
    }

    public void setOriginId(int originId) {
        this.originId = originId;
    }

    @Column(name = "quality_id", nullable = true)
    public int getQualityId() {
        return this.qualityId;
    }

    public void setQualityId(int qualityId) {
        this.qualityId = qualityId;
    }

    @Column(name = "ref_number", nullable = false)
    public String getRefNumber() {
        return this.refNumber;
    }

    public void setRefNumber(String refNumber) {
        this.refNumber = refNumber;
    }

    @Temporal(TemporalType.TIMESTAMP)
    @Column(name = "created_date", nullable = false, length = 19)
    public Date getCreatedDate() {
        return this.createdDate;
    }

    public void setCreatedDate(Date createdDate) {
        this.createdDate = createdDate;
    }

    @Column(name = "client_ref")
    public String getClientRef() {
        return this.clientRef;
    }

    public void setClientRef(String clientRef) {
        this.clientRef = clientRef;
    }

    @Column(name = "quantity", nullable = false, precision = 12, scale = 0)
    public float getQuantity() {
        return this.quantity;
    }

    public void setQuantity(float quantity) {
        this.quantity = quantity;
    }

    @Temporal(TemporalType.DATE)
    @Column(name = "from_date", length = 10)
    public Date getFromDate() {
        return this.fromDate;
    }

    public void setFromDate(Date fromDate) {
        this.fromDate = fromDate;
    }

    @Temporal(TemporalType.DATE)
    @Column(name = "to_date", length = 10)
    public Date getToDate() {
        return this.toDate;
    }

    public void setToDate(Date toDate) {
        this.toDate = toDate;
    }

    @Column(name = "remark", length = 65535)
    public String getRemark() {
        return this.remark;
    }

    public void setRemark(String remark) {
        this.remark = remark;
    }

    @Column(name = "status", nullable = false)
    public byte getStatus() {
        return this.status;
    }

    public void setStatus(byte status) {
        this.status = status;
    }

    @Column(name = "log", length = 65535)
    public String getLog() {
        return this.log;
    }

    public void setLog(String log) {
        this.log = log;
    }

    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY, mappedBy = "processingInstruction")
    public Set<WeightLoss> getWeightLosses() {
        return this.weightLosses;
    }

    public void setWeightLosses(Set<WeightLoss> weightLosses) {
        this.weightLosses = weightLosses;
    }

    @Column(name = "request_status")
    public Byte getRequestStatus() {
        return requestStatus;
    }

    public void setRequestStatus(Byte requestStatus) {
        this.requestStatus = requestStatus;
    }

    @Temporal(TemporalType.TIMESTAMP)
    @Column(name = "request_status_date", length = 19)
    public Date getRequestStatusDate() {
        return requestStatusDate;
    }

    public void setRequestStatusDate(Date requestStatusDate) {
        this.requestStatusDate = requestStatusDate;
    }

    @Column(name = "request_remark", length = 65535)
    public String getRequestRemark() {
        return requestRemark;
    }

    public void setRequestRemark(String requestRemark) {
        this.requestRemark = requestRemark;
    }

    @Temporal(TemporalType.TIMESTAMP)
    @Column(name = "credit_date", length = 19)
    public Date getCreditDate() {
        return creditDate;
    }

    public void setCreditDate(Date creditDate) {
        this.creditDate = creditDate;
    }

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "update_request_user_id")
    public User getUserByUpdateRequestUserId() {
        return userByUpdateRequestUserId;
    }

    public void setUserByUpdateRequestUserId(User userByUpdateRequestUserId) {
        this.userByUpdateRequestUserId = userByUpdateRequestUserId;
    }

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "update_completion_user_id")
    public User getUserByUpdateCompletionUserId() {
        return userByUpdateCompletionUserId;
    }

    public void setUserByUpdateCompletionUserId(User userByUpdateCompletionUserId) {
        this.userByUpdateCompletionUserId = userByUpdateCompletionUserId;
    }

    @Temporal(TemporalType.TIMESTAMP)
    @Column(name = "completion_status_date", length = 19)
    public Date getCompletionStatusDate() {
        return completionStatusDate;
    }

    public void setCompletionStatusDate(Date completionStatusDate) {
        this.completionStatusDate = completionStatusDate;
    }

    @Temporal(TemporalType.TIMESTAMP)
    @Column(name = "updated_date", length = 19)
    public Date getUpdatedDate() {
        return updatedDate;
    }

    public void setUpdatedDate(Date updatedDate) {
        this.updatedDate = updatedDate;
    }

    public Double getAllocatedWeight() {
        return allocatedWeight;
    }

    public void setAllocatedWeight(Double allocatedWeight) {
        this.allocatedWeight = allocatedWeight;
    }

    public Double getInProcessWeight() {
        return inProcessWeight;
    }

    public void setInProcessWeight(Double inProcessWeight) {
        this.inProcessWeight = inProcessWeight;
    }

    public Double getExProcessWeight() {
        return exProcessWeight;
    }

    public void setExProcessWeight(Double exProcessWeight) {
        this.exProcessWeight = exProcessWeight;
    }

    public Double getPendingWeight() {
        return pendingWeight;
    }

    public void setPendingWeight(Double pendingWeight) {
        this.pendingWeight = pendingWeight;
    }

    @OneToMany(fetch = FetchType.LAZY, mappedBy = "processingInstruction")
    public Set<WeightNote> getWeightNotes() {
        return weightNotes;
    }

    public void setWeightNotes(Set<WeightNote> weightNotes) {
        this.weightNotes = weightNotes;
    }

    public void addWeightNote(WeightNote w) {
        this.weightNotes.add(w);
    }

    @OneToMany(fetch = FetchType.LAZY, mappedBy = "processingInstruction")
    public Set<WnrAllocation> getAllocations() {
        return allocations;
    }

    public void setAllocations(Set<WnrAllocation> allocations) {
        this.allocations = allocations;
    }

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "pi_type_id")
    public PIType getPiType() {
        return piType;
    }

    public ProcessingInstruction setPiType(PIType piType) {
        this.piType = piType;
        return this;
    }
    
    

    @Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((refNumber == null) ? 0 : refNumber.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		ProcessingInstruction other = (ProcessingInstruction) obj;
		if (refNumber == null) {
			if (other.refNumber != null)
				return false;
		} else if (!refNumber.equals(other.refNumber))
			return false;
		return true;
	}

	@Override
	public String toString() {
		return "ProcessingInstruction [refNumber=" + refNumber + "]";
	}

	public double calculateInprocess() {
        List<WeightNoteReceipt> inProcessNotes = new ArrayList<>();
        Set<WeightNote> weightNotes = getWeightNotes();
        for (WeightNote w : weightNotes) {
            if (w.getStatus() != Constants.DELETED) {
                if (w.getType().equals("IP")) {
                    for (WeightNoteReceipt weightNoteReceipt : w.getWeightNoteReceipts()) {
                        if (weightNoteReceipt.getStatus() != Constants.DELETED) {
                            inProcessNotes.add(weightNoteReceipt);
                        }
                    }
                }
            }
        }
        double kg = 0;
        for (WeightNoteReceipt w : inProcessNotes) {
            kg += w.getGrossWeight() - w.getTareWeight();
        }
        return kg / 1000;
    }

    public double calculateExprocess() {
        List<WeightNoteReceipt> exProcessNotes = new ArrayList<>();
        Set<WeightNote> weightNotes = getWeightNotes();
        for (WeightNote w : weightNotes) {
            if (w.getStatus() != Constants.DELETED) {
                if (w.getType().equals("XP")) {
                    for (WeightNoteReceipt weightNoteReceipt : w.getWeightNoteReceipts()) {
                        if (weightNoteReceipt.getStatus() != Constants.DELETED) {
                            exProcessNotes.add(weightNoteReceipt);
                        }
                    }
                }
            }
        }
        double kg = 0;
        for (WeightNoteReceipt w : exProcessNotes) {
            kg += w.getGrossWeight() - w.getTareWeight();
        }
        return kg / 1000;
    }

    public double calculateAllocated() {
        double allocated = 0;

        for (WnrAllocation allocation : allocations) {
            WeightNoteReceipt w = allocation.getWeightNoteReceiptByWnrId();
            allocated += w.getGrossWeight() - w.getTareWeight();
        }

        allocatedWeight = allocated / 1000.0;

        return allocatedWeight;
    }

    public void calculateInfo() {
        double allocated = 0;

        for (WnrAllocation allocation : allocations) {
            WeightNoteReceipt w = allocation.getWeightNoteReceiptByWnrId();
            allocated += w.getGrossWeight() - w.getTareWeight();
        }

        allocatedWeight = allocated / 1000.0;

        List<WeightNoteReceipt> inProcessNotes = new ArrayList<>();
        List<WeightNoteReceipt> exProcessNotes = new ArrayList<>();
        Set<WeightNote> weightNotes = getWeightNotes();
        for (WeightNote w : weightNotes) {
            if (w.getStatus() != Constants.DELETED) {
                if (w.getType().equals("IP")) {
                    for (WeightNoteReceipt weightNoteReceipt : w.getWeightNoteReceipts()) {
                        if (weightNoteReceipt.getStatus() != Constants.DELETED) {
                            inProcessNotes.add(weightNoteReceipt);
                        }
                    }
                } else {
                    for (WeightNoteReceipt weightNoteReceipt : w.getWeightNoteReceipts()) {
                        if (weightNoteReceipt.getStatus() != Constants.DELETED) {
                            exProcessNotes.add(weightNoteReceipt);
                        }
                    }
                }
            }
        }
        double kg = 0;
        for (WeightNoteReceipt w : inProcessNotes) {
            kg += w.getGrossWeight() - w.getTareWeight();
        }
        inProcessWeight = kg / 1000;

        kg = 0;
        for (WeightNoteReceipt w : exProcessNotes) {
            kg += w.getGrossWeight() - w.getTareWeight();
        }
        exProcessWeight = kg / 1000;
        pendingWeight = allocatedWeight - inProcessWeight;

    }

    public Boolean getCompletable() {
        Boolean completable = true;
        if (getWeightNotes() != null) {
            Set<WeightNote> wns = getWeightNotes();
            if (wns.size() != 0) {
                for (WeightNote wn : wns) {
                    if (wn.getStatus().equals(Constants.PENDING)) {
                        completable = false;
                    }
                }
            }
        }
        return completable;
    }

    public ProcessingInstruction setCompletable(Boolean completable) {
        isCompletable = completable;
        return this;
    }
    
    @Transient
    private boolean isCompleted() {
        return getCompletionStatus() == CompletionStatus.COMPLETED;
    }
    
    
    @Enumerated(EnumType.STRING)
    @Column(name = "completionStatus1")
    public CompletionStatus getCompletionStatus() {
		return completionStatus;
	}

	public void setCompletionStatus(CompletionStatus completionStatus) {
		this.completionStatus = completionStatus;
	}

    @Enumerated(EnumType.STRING)
    @Column(name = "requestStatusEnum1")
	public RequestStatus getRequestStatusEnum() {
		return requestStatusEnum;
	}

	public void setRequestStatusEnum(RequestStatus requestStatusEnum) {
		this.requestStatusEnum = requestStatusEnum;
	}

	public void updateCompletionStatus(CompletionStatus status, User user) throws ActionNotPermitted {
        if(status == CompletionStatus.COMPLETED) {
            List<WeightNote> wns = getWeightNotes().stream().filter(wn -> ! wn.isCompleteted() && ! wn.isDeleted()).collect(Collectors.toList());
            if(wns.size() > 0) {
                throw new ActionNotPermitted(String.format("Some wns: %s is(are) not completed. Please complete it before completing this instruction", 
                    wns.stream().map(wn -> wn.getRefNumber()).collect(Collectors.joining(","))));
                
            }
        }
		this.setCompletionStatus(status);
        this.setUserByUpdateCompletionUserId(user);
        this.setCompletionStatusDate(new Date());
        this.registerEvent(new PIUpdatedEvent(this));
        if(isCompleted()) {
            this.registerEvent(new PIFinishedEvent(this, user));
        }
    }
	
	public void updateRequestStatus(RequestStatus status, User user) throws ActionNotPermitted {
		if(completionStatus == CompletionStatus.COMPLETED) {
			throw new ActionNotPermitted("Can not update request status because the completion status is completed.");
		}
		this.setRequestStatusEnum(status);
		this.setUserByUpdateRequestUserId(user);
        this.setRequestStatusDate(new Date());
        this.registerEvent(new PIUpdatedEvent(this));
    }
    
    public void initNewSelf(User user) {
    		setUpdatedDate(new Date());
    		setCreatedDate(new Date());
        setUser(user);
        setRefNumber(new Date().toString());
        registerEvent(new NewlyCreatedPIEvent(this));
        registerEvent(new PIUpdatedEvent(this));
        setCreatedUser(user);
    }
    
    public void updateSelf(User user) {
        setUpdatedDate(new Date());
        setUser(user);
        registerEvent(new PIUpdatedEventByRef(refNumber));
    }
    
    
}
